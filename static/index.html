<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Clojure concurrency introduction</title>

  <meta name="viewport" content="width=device-width"/>

  <link rel="stylesheet" href="./css/reset.css" type="text/css"/>
  <link rel="stylesheet" href="./css/showoff.css" type="text/css"/>

  <script type="text/javascript" src="./js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="./js/jquery.cycle.all.js"></script>
	<script type="text/javascript" src="./js/jquery-print.js"></script>
  <script type="text/javascript" src="./js/jquery.batchImageLoad.js"></script>

  <script type="text/javascript" src="./js/jquery.doubletap-0.1.js"></script>

  <script type="text/javascript" src="./js/fg.menu.js"></script>
  <script type="text/javascript" src="./js/showoff.js"></script>
  <script type="text/javascript" src="./js/jTypeWriter.js"> </script>
  <script type="text/javascript" src="./js/sh_main.min.js"></script>
  <script type="text/javascript" src="./js/core.js"></script>
  <script type="text/javascript" src="./js/showoffcore.js"></script>
  <script type="text/javascript" src="./js/coffee-script.js"></script>

  <link type="text/css" href="./css/fg.menu.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/theme/ui.all.css" media="screen" rel="stylesheet" />
  <link type="text/css" href="./css/sh_style.css" rel="stylesheet" >

  
    <link rel="stylesheet" href="./file/left_aligned_bullets.css" type="text/css"/>
  

  

  <script type="text/javascript">
  $(function(){
      setupPreso(false, './');
  });
  </script>

</head>

<body>

<a tabindex="0" href="#search-engines" class="fg-button fg-button-icon-right ui-widget ui-state-default ui-corner-all" id="navmenu"><span class="ui-icon ui-icon-triangle-1-s"></span>slides</a>
<div id="navigation" class="hidden"></div>

<div id="help">
  <table>
    <tr><td class="key">z, ?</td><td>toggle help (this)</td></tr>
    <tr><td class="key">space, &rarr;</td><td>next slide</td></tr>
    <tr><td class="key">shift-space, &larr;</td><td>previous slide</td></tr>
    <tr><td class="key">d</td><td>toggle debug mode</td></tr>
    <tr><td class="key">## &lt;ret&gt;</td><td>go to slide #</td></tr>
    <tr><td class="key">c, t</td><td>table of contents (vi)</td></tr>
    <tr><td class="key">f</td><td>toggle footer</td></tr>
    <tr><td class="key">r</td><td>reload slides</td></tr>
    <tr><td class="key">n</td><td>toggle notes</td></tr>
    <tr><td class="key">p</td><td>run preshow</td></tr>
  </table>
</div>

<div class="buttonNav">
  <input type="submit" onClick="prevStep();" value="prev"/>
  <input type="submit" onClick="nextStep();" value="next"/>
</div>

<div id="preso">loading presentation...</div>
<div id="footer">
  <span id="slideInfo"></span>
  <span id="debugInfo"></span>
  <span id="notesInfo"></span>
</div>

<div id="slides" class="offscreen" style="display:none;">
<div class="slide" data-transition="none"><div class="content" ref="agenda/01_intro/1">
<h1>Clojure concurrency</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/01_intro/2">
<h1>Agenda</h1>

<ul>
<li>Concurrency and why it matters </li>
<li>Current approaches (and why they fail)</li>
<li>Clojure concurrency take</li>
<li>Clojure STM drill down </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/01_intro/3">
<p class="notes">
Concurrency deals with structuring our software to handle non deterministic control flow , parallelism deals with running operation on multiple cores for better throughput (http://tinyurl.com/bv483my).</p>

<h1>Concurrency and why is matters?</h1>

<ul>
<li>The end of free lunch</li>
<li>Concurrency != Parallelism</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/01_intro/4">
<p class="notes">
Livelock Threads are often busy responding to one another, if two threads are responding endlessly to one another they are livelocked, it similar to two people passing in the same corridor each trying to give head way to another.
Starvation happens when a thread tries to access a shared resource but get little or not access to it, if for example one threads calls frequently a long synchronized method on an object it locks that object for other threads.</p>

<h1>Common issues</h1>

<ul>
<li>Deadlocks</li>
<li>Livelocks </li>
<li>Race conditions</li>
<li>Starvation </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/02_approch/1">
<h1>Common techniques</h1>

<ul>
<li>Locks</li>
<li>Actors</li>
<li>Dataflow</li>
<li>STM</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/02_approch/2">
<h1>Locks</h1>

<ul>
<li>Prevalent in most languages today</li>
<li>Manual low level mechanism </li>
<li>Very error prone</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="agenda/02_approch/3">
<p class="notes">Yes locks in Clojure are possible, not too surprising since the good java interop should enable Clojure in Clojure 
A basic lock example, notice that the shorter version cannot complete until the longer one releases its lock</p>

<pre class="sh_clojure"><code>(def o (Object.))
(defn sleep-lock [interval] 
  (future 
    (locking o 
      (do 
        (Thread/sleep interval) 
        (str (java.util.Date.))))))

(def f1 (sleep-lock 500))
(def f2 (sleep-lock 100))
(println (str "longer " @f1))
(println (str "shorter " @f2))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="agenda/02_approch/4">
<p class="notes">In erroneous situation its very hard to recover and decide which lock to release take etc..</p>

<h1>Lock pitfalls</h1>

<ul>
<li>Taking too few locks<br/>
<li>Taking the wrong locks </li>
<li>Taking locks in the wrong order</li>
<li>Error recovery</li>
<li>Hard to compose</li>
</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="clojure/01_intro/1">
<h1>Clojure</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content center" ref="clojure/01_intro/2">
<p class="notes">
* Value: an immutable magnitude, quantity, number, or composite of these
* Identity: a putative entity we associate with a series of causally related values (states) over time
* State: value of an identity at a moment in time
* Time: relative before/after ordering of causal values.</p>

<h1>Value identity state and time</h1>

<p><img src="./file/clojure/value-identity-state-and-time.svg" alt="visat" title="value-identity-state-and-time">
</img>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="clojure/02_adts/1">
<p class="notes">Clojure takes immutability one step further</p>

<h1>Persistent data structures</h1>

<ul>
<li>Implemented as 32 bit partitioned trees</li>
<li>Immutable</li>
<li>Data sharing </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code style execute" ref="clojure/02_adts/2">
<p class="notes">Here we see that the original value hasn't changed</p>

<h1>Immutability</h1>

<pre class="sh_clojure"><code>(def a [1 2 3])

(conj a 4)

(println a)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content full-page-image" ref="clojure/02_adts/3">
<p class="notes">Clojure ADT are implemented as 32bit partitioned trees, in this case we see the tree of a vector</p>

<p><img src="./file/clojure/persistentvector.png" width="581" height="235" alt="Persistent vector" title="persistent-vector">
</img>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content center" ref="clojure/02_adts/4">
<p class="notes">The binary partitioning scheme is to divide each level in the tree into 5 bits, the most left hand bits are those of the root (relative the tree height)</p>

<p><img src="./file/clojure/bit-partitioning.svg" alt="Bit partitioning" title="binary-partitoining">
</img>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content code small" ref="clojure/02_adts/5">
<p class="notes">arrayFor is looking for the matching level node, the loop goes through 5 bits at a time shifting </p>

<h1>Nth</h1>

<pre class="sh_java"><code>public Object nth(int i){
        ensureEditable();// transient access
        Object[] node = arrayFor(i);
        return node[i &amp; 0x01f];// the 0x01f masks the lower 5 bits
} 

private Object[] arrayFor(int i){
      if(i &gt;= 0 &amp;&amp; i &lt; cnt) {
         if(i &gt;= tailoff())// tail is the current insertion buffer
            return tail;
         Node node = root;
         for(int level = shift; level &gt; 0; level -= 5) // shift is 5*(1+ h)
           node = (Node) node.array[(i &gt;&gt;&gt; level) &amp; 0x01f];
           return node.array;
         }
       throw new IndexOutOfBoundsException();
 } </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/03-refs-intro/1">
<h1>Clojure reference types</h1>

<ul>
<li>Vars: global per thread value </li>
<li>Agents: asynchronous single object store </li>
<li>Atoms: simple CAS semantics</li>
<li>Refs: STM managed references </li>
<li>All implements ARef (some IFn)</li>
<li>Muatated by applying fn </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content center" ref="clojure/03-refs-intro/2">
<h1>Reference categorization</h1>

<table><thead>
<tr>
<td align="left"/>
<td align="center">Asynchronous</td>
<td align="center">Synchronous</td>
</tr>
</thead><tbody>
<tr>
<td align="left">Coordinated</td>
<td align="center"/>
<td align="center">Ref</td>
</tr>
<tr>
<td align="left">Independent</td>
<td align="center">Agent</td>
<td align="center">Atom</td>
</tr>
</tbody></table></div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/04-vars/1">
<h1>Vars</h1>

<ul>
<li>Per thread global store</li>
<li>defn and def use var</li>
<li>Dynamic bindings </li>
<li>Mutation: set!, def, defn</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/04-vars/2">
<p class="notes">set! and binding</p>

<pre class="sh_clojure"><code>(def v 1)

(alter-var-root #'*out* (constantly *out*))

(defn set-5 [o] 
  (binding [v o] ; v bound to TL
    (set! v 5)
    (println "p1:" v))
  )

(let [thread (Thread. #(set-5 v))]
  (.start thread)
  (.join thread)
  (println "p2:" v)) </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/04-vars/3">
<h1>Usage</h1>

<ul>
<li>Per thread storage is required</li>
<li>Configuration (like *out*)</li>
<li>AOP in functions</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code" ref="clojure/04-vars/4">
<pre class="sh_java"><code>Var(Namespace ns, Symbol sym, Object root){
  this(ns, sym);
  this.root = root;
  ++rev;
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="clojure/04-vars/5">
<p class="notes">
Framing implementation:
 2. dvals holds current Frame which holds bindings and previous Frame, 
 3. pushThreadBindings invoked by bindings, stores a new Frame into dvals,
 4. A symmetric popThreadBindings pulls previous Frame.</p>

<pre class="sh_java"><code>public final class Var extends ARef implements IFn, IRef, Settable{

 static class Frame {
  Associative bindings; // Var-&gt;TBox
  Frame prev;

  ...

 }


  static final ThreadLocal&lt;Frame&gt; dvals = new ThreadLocal&lt;Frame&gt;(){
     ...
  };


  public static void pushThreadBindings(Associative bindings){
    Frame f = dvals.get();// current frame
    Associative bmap = f.bindings;
    for(ISeq bs = bindings.seq(); bs != null; bs = bs.next())
          {
          IMapEntry e = (IMapEntry) bs.first();
          Var v = (Var) e.key();

           if(!v.dynamic)
                 throw new IllegalStateException(String.format("Can't dynamically bind non-dynamic var: %s/%s", v.ns, v.sym));

          v.validate(v.getValidator(), e.val());
          v.threadBound.set(true);
          // assoc new Frame value
          bmap = bmap.assoc(v, new TBox(Thread.currentThread(), e.val()));
          }
    dvals.set(new Frame(bmap, f));
  }

   ...
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/05-agents/1">
<h1>Agents intro</h1>

<ul>
<li>Single value store</li>
<li>Manipulated via messages (Actor like)</li>
<li>Mutation: send, send-of</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/05-agents/2">
<p class="notes">This example show how we send tasks to the agent and wait for it to finish processing, we use send-off and not send since it blocks, the difference is with the thread pools that will be used to process this, see next..</p>

<pre class="sh_clojure"><code>(def a (agent 5)) 

(dotimes [i 5] 
  ; we use send-of and not send
  (send-off a #(do (Thread/sleep 100) (inc %))))

(println "p1:" @a)

(await a)

(println "p2:" @a)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/05-agents/3">
<h1>Agents Usage</h1>

<ul>
<li>Accessing single threaded components</li>
<li>Side effects in STM transactions</li>
<li>Queue processing </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code small" ref="clojure/05-agents/4">
<p class="noted">The send implementation is calling dispatch</p>

<pre class="sh_clojure"><code>(defn send
 "Dispatch an action to an agent. Returns the agent immediately.
  Subsequently, in a thread from a thread pool, the state of the agent
  will be set to the value of:

 (apply action-fn state-of-agent args)"
 {:added "1.0"
  :static true}
  [^clojure.lang.Agent a f &amp; args]
  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args false)) </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="clojure/05-agents/5">
<p class="notes">dispatch creates a new actions and dispatches it</p>

<pre class="sh_java"><code>public class Agent extends ARef { 

  ...

  AtomicReference&lt;ActionQueue&gt; aq = new AtomicReference&lt;ActionQueue&gt;(ActionQueue.EMPTY);

  public Object dispatch(IFn fn, ISeq args, boolean solo) {

     ... 

    Action action = new Action(this, fn, args, solo);
    dispatchAction(action);

    return this;
  } </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="clojure/05-agents/6">
<p class="notes">dispatchAction gets the current transaction, if it exists it sets the action on it
       The Agent's queue implementation is based on Treiber's algorithm (see http://tinyurl.com/37mydc) for non blocking stack.</p>

<pre class="sh_java"><code> static void dispatchAction(Action action){
   LockingTransaction trans = LockingTransaction.getRunning();
   if(trans != null)// if called within transaction
        trans.enqueue(action);
   else if(nested.get() != null)
         {
         nested.set(nested.get().cons(action));
         }
  else
     action.agent.enqueue(action);
 } 

 ... 

 void enqueue(Action action){// push
   boolean queued = false;
   ActionQueue prior = null;
   while(!queued)// while we didn't manage to CAS 
         {
         prior = aq.get();
         queued = aq.compareAndSet(prior, 
            new ActionQueue((IPersistentStack)prior.q.cons(action), prior.error));
         }

   if(prior.q.count() == 0 &amp;&amp; prior.error == null)// only first action 
         action.execute();
 } </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="clojure/05-agents/7">
<p class="notes">The execute invokes the action, if send is used pooledExecutor is used (closer to the cpu count of threads less context switching) if send-of is used then a cached thread pool is used, a new Thread (potentially) will be created for each action (good for blocking actions).</p>

<pre class="sh_java"><code>void execute(){
    try
        {
        if(solo)
            soloExecutor.execute(this);// dynamic pool 
        else
            pooledExecutor.execute(this);// fixed size pool (cpu cores + 2)
        }
    catch(Throwable error)
        {
        if(agent.errorHandler != null)
            {
            try
                {
                agent.errorHandler.invoke(agent, error);
                }
            catch(Throwable e) {} // ignore errorHandler errors
            }
        }
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="clojure/05-agents/8">
<p class="notes">pop implementation, each one of these is running a seperate thread, the if before the finally is pulling the next message</p>

<pre class="sh_java"><code> static void doRun(Action action){// invoked from run in a Thread 
        try
              {
              nested.set(PersistentVector.EMPTY);

              Throwable error = null;
              try
                  {// the current message processing
                   Object oldval = action.agent.state;
                   Object newval =  action.fn.applyTo(RT.cons(action.agent.state, action.args));
                   action.agent.setState(newval);
                   action.agent.notifyWatches(oldval,newval);
                  }
             catch(Throwable e)
                  {
                   error = e;
                  }

              ... 

              boolean popped = false;
              ActionQueue next = null;
              while(!popped)
                  {
                   ActionQueue prior = action.agent.aq.get();
                   next = new ActionQueue(prior.q.pop(), error);
                   popped = action.agent.aq.compareAndSet(prior, next);
                  }

              if(error == null &amp;&amp; next.q.count() &gt; 0) // pulling more actions
                   ((Action) next.q.peek()).execute();
              }
        finally

         ...    

   }</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/06-atoms/1">
<h1>Atoms</h1>

<ul>
<li>Synchronous non transactional storage</li>
<li>Has CAS semantics</li>
<li>Mutation: reset!, compare-and-set! and swap!</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/06-atoms/2">
<p class="notes">replaces the current value without taking older value into account</p>

<pre class="sh_clojure"><code>(def x (atom 1))
(reset! x 2)
(println @x)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/06-atoms/3">
<p class="notes">This compare-and-set! fails since we reset curr-val before the second thread had a chance to CAS.</p>

<pre class="sh_clojure"><code>(def x (atom 1))

(alter-var-root #'*out* (constantly *out*))

(defn update-atom []
  (let [curr-val @x]
    (println "update-atom: curr-val =" curr-val) ; -&gt; 1
    (Thread/sleep 50) ; give reset! time to run
    (println
      (compare-and-set! x curr-val (inc curr-val))))) ; -&gt; false

(let [thread (Thread. update-atom)]
  (.start thread)
  (Thread/sleep 25) 
  (reset! x 3) ; taken after curr-val set
  (.join thread)) 

  (println @x)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/06-atoms/4">
<p class="notes">unlike CAS which fails, swap! repeatedly replay the function until no collision is made we can see that its running twice</p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def x (atom 1))


(defn update-atom [curr-val]
  (println "update-atom: curr-val =" curr-val)
  (Thread/sleep 50) ; give reset! time to run
  (inc curr-val))

(let [thread (Thread. #(swap! x update-atom))]
  (.start thread)
  (Thread/sleep 25) ; give swap! time to call update-atom
  (reset! x 3)
  (.join thread)) 

(println @x)</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/06-atoms/5">
<h1>Usage</h1>

<ul>
<li>Global state without coordination (memoization)</li>
<li>Reducing STM overhead</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code" ref="clojure/06-atoms/6">
<p class="notes">deref state and ctor, here we see that the atom stores the reference in an atomic container</p>

<pre class="sh_java"><code>final public class Atom extends ARef{
final AtomicReference state;

public Atom(Object state){
  this.state = new AtomicReference(state);
}

...

public Object deref(){
return state.get();
} </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code" ref="clojure/06-atoms/7">
<p class="notes">reset!, compare-and-set implementation, nothing too exciting </p>

<pre class="sh_java"><code> public Object reset(Object newval){
   Object oldval = state.get();
   validate(newval);
   state.set(newval);
   notifyWatches(oldval, newval);
   return newval;
}  

public boolean compareAndSet(Object oldv, Object newv){
  validate(newv);
  boolean ret = state.compareAndSet(oldv, newv);
  if(ret)
      notifyWatches(oldv, newv);
  return ret;
} </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code" ref="clojure/06-atoms/8">
<p class="notes">swap! implementation, we see the loop as long as the compareAndSet fail the loop will carry on</p>

<pre class="sh_java"><code>public Object swap(IFn f, Object x, Object y, ISeq args) {
  for(; ;)
      {
        Object v = deref();
        Object newv = f.applyTo(RT.listStar(v, x, y, args));
        validate(newv);
        if(state.compareAndSet(v, newv))
              {
              notifyWatches(v, newv);
              return newv;
              }
      }
}  </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/08-refs/1">
<h1>Refs</h1>

<ul>
<li>Coordinated storage using STM</li>
<li>Mutation: ref-set, alter, commute </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="clojure/08-refs/2">
<p class="notes">"Atomic" commit or retry, "Consistent" constraints on the data will not be violated, "Isolated" changes made inside a transaction are not visible outside the transaction until it commits</p>

<h1>Transactions</h1>

<ul>
<li>A unit of work</li>
<li>ACI(D)</li>
<li>Should be side effect free (retries)</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content center" ref="clojure/08-refs/3">
<p class="notes">commit if successful, retry if conflict (up to RETRY_LIMIT currently 10,000), this is a simplification of the real life cycle which has 5 states</p>

<h1>Life cycle</h1>

<p><img src="./file/clojure/transaction.svg" alt="Transaction" title="transaction">
</img>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/08-refs/4">
<p class="notes">A basic alter example</p>

<pre class="sh_clojure"><code>(def account (ref 0))

(defn deposit [amount]
  (alter account + amount ))

(def f (future (dosync (deposit 5))))

(do 
  (deref f)
  (println @account))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/08-refs/5">
<p class="notes">ref-set usage is frowned upon alter is preferable</p>

<pre class="sh_clojure"><code>(def account (ref 0))

(def f 
  (future 
    (dosync 
     (ref-set account (+ 5 @account)))))

(do 
  (deref f)
  (println @account))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute small" ref="clojure/08-refs/6">
<p class="notes">
Here we how see an example for retries (T2 retries couple of times), this can be prevented in this case since + is commutative
The reason that T2 is being retried is because T1 is older and has tinfo set (meaning it made a write change)</p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def account (ref 0))

(defn deposit [amount] (alter account + amount ))

(def f1 (future 
      (dosync
         (deposit -2)
         (Thread/sleep 500)
         (println (str "T1 running") @account)
         (deposit 5))))

(def f2 (future 
      (dosync
         (println (str "T2 running") @account)
         (deposit 5))))

(do 
  (deref f1)
  (deref f2)
  (println @account))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute small" ref="clojure/08-refs/7">
<p class="notes">commute, here we use commute on a commutative operation (+) in order to avoid retries. </p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def account (ref 0))

(defn deposit [amount] (commute account + amount))

(def f1 (future 
      (dosync
         (deposit -2)
         (Thread/sleep 500)
         (println (str "T1 running") @account)
         (deposit 5))))

(def f2 (future 
      (dosync
         (println (str "T2 running") @account)
         (deposit 5))))

(do 
  (deref f1)
  (deref f2)
  (println @account))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute smaller" ref="clojure/08-refs/8">
<p class="notes">Write skew example http://paste.lisp.org/display/87117#1</p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def account1 (ref 100))
(def account2 (ref 100))


(defn deposit  [account amount]
  (dosync
    (if (&gt; (+ @account2  @account1) 0)
      (alter account + amount))))


(let [deposits1 (repeat 10 #(deposit account1 -200)) 
      deposits2 (repeat 10 #(deposit account2 -200))]
  (dorun (apply pcalls (interleave deposits1 deposits2)))
  (println @account1)
  (println @account2))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute smaller" ref="clojure/08-refs/9">
<p class="notes">Here we use ensure to prevent the write skew issue, ensure prevents other transactions to perform write operations on the ref.</p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def account1 (ref 100))
(def account2 (ref 100))


(defn deposit  [account amount]
  (dosync
    (ensure account1)
    (ensure account2)
    (if (&gt; (+ @account2  @account1) 0)
      (alter account + amount))))


(let [deposits1 (repeat 10 #(deposit account1 -200)) 
      deposits2 (repeat 10 #(deposit account2 -200))]
  (dorun (apply pcalls (interleave deposits1 deposits2)))
  (println @account1)
  (println @account2))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/10-watchers-and-validators/1">
<p class="notes">We can set validators on var/ref/agent/atom </p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def num (ref 0 :validator integer?))

(try
  (dosync
    (ref-set num 1) 
    ; no commit, transaction is aborted
    (ref-set num "foo")) 
      (catch Exception e (println (str e))))</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code execute" ref="clojure/10-watchers-and-validators/2">
<p class="notes">We can add watchers, the watch fn will be called synchronously, on the agent's thread if an agent, before any pending sends if agent or ref. </p>

<pre class="sh_clojure"><code>(alter-var-root #'*out* (constantly *out*))

(def num (ref 0))

(add-watch num nil 
  (fn [key ref old new] (println old new )))

  (dosync
    (ref-set num "foo"))</code></pre>
</div>
</div><div class="slide" data-transition="fade"><div class="content bullets incremental" ref="stm/01-intro">
<h1>Clojure STM</h1>

<ul>
<li>Implementation based upon MVCC </li>
<li>Transaction operate under snpashot isolation</li>
<li>Optimistic, assumes low chances of write collisions</li>
<li>No deadlocks, livelocks or race conditions possible</li>
<li>Implemention core: Ref and LockingTransaction </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="stm/02-locking-transaction/1">
<h1>LockingTransaction</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/02-locking-transaction/2">
<p class="notes">The LockingTransaction is held in thread local storage, the info class holds the transaction status, most status are self explanatory KILLED is set when one TX barges another
info is also a part of lock-free strategy to mark Refs as having an uncommitted change</p>

<pre class="sh_java"><code>public class LockingTransaction{ 

  final static ThreadLocal&lt;LockingTransaction&gt; transaction =
                             new ThreadLocal&lt;LockingTransaction&gt;(); 

  static final int RUNNING = 0; // executing code
  static final int COMMITTING = 1; // committing changes to refs
  static final int RETRY = 2; // will be retied
  static final int KILLED = 3; // barged 
  static final int COMMITTED = 4; // done committing

  public static class Info{
    final AtomicInteger status;
    final long startPoint;
    final CountDownLatch latch;


    public Info(int status, long startPoint){
          this.status = new AtomicInteger(status);
          this.startPoint = startPoint;
          this.latch = new CountDownLatch(1);
    }

    public boolean running(){
          int s = status.get();
          return s == RUNNING || s == COMMITTING;
    }
  }</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code small" ref="stm/02-locking-transaction/3">
<p class="notes">runInTransaction is called from the dosync macro, it gets the thread local LockingTransaction (if exists)</p>

<pre class="sh_java"><code>static public Object runInTransaction(Callable fn) throws Exception{
  LockingTransaction t = transaction.get();
  if(t == null)
        transaction.set(t = new LockingTransaction());

  if(t.info != null)
       return fn.call();

  return t.run(fn);
} </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/02-locking-transaction/4">
<p class="notes">
The run method is the core of the transaction lifecycle, in it the retry loop is running </p>

<pre class="sh_java"><code>Object run(Callable fn) throws Exception{

  ...

  for(int i = 0; !done &amp;&amp; i &lt; RETRY_LIMIT; i++)
       {
       try
           {
           getReadPoint();// tracks order of retries across all transactions.
           if(i == 0)
                {
                 startPoint = readPoint;
                 startTime = System.nanoTime();
                }
           info = new Info(RUNNING, startPoint);
           ret = fn.call();// calling the body of dosync
           } 

        ...

       }
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="stm/03-snapshot-isolation/1">
<h1>Snapshot isolation</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content code style small" ref="stm/03-snapshot-isolation/2">
<p class="notes">vals include commuted values (unlike sets)</p>

<pre class="sh_java"><code>// modified by current TX Refs -&gt; in-transaction values. 
final HashMap&lt;Ref, Object&gt; vals = new HashMap&lt;Ref, Object&gt;();

// Refs modified by current TX by using ref-set or alter 
final HashSet&lt;Ref&gt; sets = new HashSet&lt;Ref&gt;(); </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/03-snapshot-isolation/3">
<p class="notes">here we see alter, it gets the old value, applies the fn to it and sets it back </p>

<pre class="sh_java"><code>public class Ref extends ARef implements IFn, Comparable&lt;Ref&gt;, IRef{ 

 ...

 public Object alter(IFn fn, ISeq args) {
   LockingTransaction t = LockingTransaction.getEx();
   return t.doSet(this, fn.applyTo(RT.cons(t.doGet(this), args)));
 }</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/03-snapshot-isolation/4">
<p class="notes">Here we see how ref value is obtained within the TX (alter calls it), if it doesn't have a TX value the value is looked for in the tvals</p>

<pre class="sh_java"><code>Object doGet(Ref ref){
  if(!info.running())
        throw retryex;
  if(vals.containsKey(ref))
        return vals.get(ref);
  try
        {
        ref.lock.readLock().lock();
        if(ref.tvals == null)
               throw new IllegalStateException(ref.toString() + " is unbound.");
        Ref.TVal ver = ref.tvals;
        do
              {
                if(ver.point &lt;= readPoint)  {
                  return ver.val;
                }
              } while((ver = ver.prior) != ref.tvals);
       }
  finally
        {
        ref.lock.readLock().unlock();
        }
  //no version of val precedes the read point
  ref.faults.incrementAndGet();
  throw retryex;
 }</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/03-snapshot-isolation/5">
<p class="notes">The symetric set value method</p>

<pre class="sh_java"><code>Object doSet(Ref ref, Object val){
  if(!info.running())
         throw retryex;
  if(commutes.containsKey(ref))
        throw new IllegalStateException("Can't set after commute");
  if(!sets.contains(ref))
        {
        sets.add(ref);
        lock(ref);
        }
  vals.put(ref, val);
  return val;
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="stm/04-ref/1">
<h1>Ref</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content code small" ref="stm/04-ref/2">
<p class="notes">Each Ref stores multiple versions of committed values in a circular list tvals</p>

<h1>Ref</h1>

<pre class="sh_java"><code>public class Ref extends ARef implements IFn, Comparable&lt;Ref&gt;, IRef{ 
 ...

 public static class TVal{
   Object val;// the committed value
   long point;// transaction commit id
   long msecs;// TVal creation time
   TVal prior;// older commits
   TVal next;// newer commits
 } 

 TVal tvals;
 ...
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content center" ref="stm/04-ref/3">
<p class="notes">Values are added if faults happend</p>

<h1>Ref history list</h1>

<p><img src="./file/stm/tvals-versions.svg" alt="Tvals version" title="tvals">
</img>
</p>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="stm/04-ref/4">
<p class="notes">Adding the faulted value into the tvals list reduces the likelihood for other TX's to have faults (assuming they started after the committing TX)</p>

<h1>Fault</h1>

<ul>
<li>A TX read a ref that has no local value</li>
<li>All existing tvals were committed after TX has began</li>
<li>This causes a retry and increment the faults <a href="/#54">counter</a></li>
<li>First commit on faulty Ref will be added to tvals </li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="stm/04-ref/5">
<p class="notes">A knows that according to the tinfo field on the Ref</p>

<h1>Write conflict and Barging</h1>

<ul>
<li>TX A try modifying a Ref that TX B changed without committing</li>
<li>A will try to Barge B</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code small" ref="stm/04-ref/6">
<p class="notes">
In order for A to barge B (else A will retry):
1. A must have been running for at least 1/100th of a second (BARGE_WAIT_NANOS)
2. A started before B (favors older txns)
3. B has a status of RUNNING and can be changed to KILLED
If B status is set to KILLED it will retry</p>

<pre class="sh_java"><code>private boolean barge(Info refinfo){
  boolean barged = false;
  // if this transaction is older
  // try to abort the other
  if(bargeTimeElapsed() &amp;&amp; startPoint &lt; refinfo.startPoint)
        {
    barged = refinfo.status.compareAndSet(RUNNING, KILLED);
    if(barged)
        refinfo.latch.countDown();
        }
  return barged;
}  </code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="stm/05-locks/1">
<p class="notes">
1. We saw that locks are held briefly in the doSet doGet methods, 
2. The one case that a look is held for the entire TX is if ensure was called
3. The tinfo field save us the need to lock the Ref for the entier TX since we can check for pending writers </p>

<h1>locks</h1>

<ul>
<li>Each ref has ReentrantReadWriteLock</li>
<li>Many TX's can read only one can write</li>
<li>Lock free strategy

<ul>
<li>Lock are held briefly (not entire TX)* </li>
<li>Ref.tinfo marks an active write</li>
</ul></li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content code smaller" ref="stm/05-locks/2">
<p class="notes">Here we see the locking method which is called from doSet, here we can see how write conflict is detected using the tinfo field on the Ref</p>

<pre class="sh_java"><code>
Object lock(Ref ref){
  releaseIfEnsured(ref); //can't upgrade readLock, so release it

  boolean unlocked = true;
  try
        {
        tryWriteLock(ref);// trying to get the write lock to the ref 
        unlocked = false;

        if(ref.tvals != null &amp;&amp; ref.tvals.point &gt; readPoint)
               throw retryex;
        Info refinfo = ref.tinfo;

        //write lock conflict
        if(refinfo != null &amp;&amp; refinfo != info &amp;&amp; refinfo.running()) // did any TX has uncommited write?
              {
              if(!barge(refinfo))
                    {
                    ref.lock.writeLock().unlock();
                    unlocked = true;
                    return blockAndBail(refinfo);
                    }
              }
        ref.tinfo = info;
        return ref.tvals == null ? null : ref.tvals.val;
        }
  finally
        {
        if(!unlocked)
              ref.lock.writeLock().unlock();
        }
}</code></pre>
</div>
</div><div class="slide" data-transition="none"><div class="content subsection" ref="summary/01-about/1">
<h1>Commit the talk</h1>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets" ref="summary/01-about/2">
<h1>Find me online</h1>

<ul>
<li>Twitter <a href="http://twitter.com/#!/narkisr/">@narkisr</a><br/>
<li>My projects on <a href="https://github.com/narkisr">github</a> </li>
<li>Blog <a href="http://narkisr.com">narkisr.com</a></li>
<li>Linkedin <a href="http://il.linkedin.com/in/narkisr">profile</a> </li>
</li>
</ul>
</div>
</div><div class="slide" data-transition="none"><div class="content bullets incremental" ref="summary/02-biblio">
<h1>STM Resources</h1>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Snapshot_isolation">Snapshot isolation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">MVCC</a></li>
<li><a href="http://java.ociweb.com/mark/stm/article.html">Clojure STM article</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Software_transactional_memory">Haskell STM</a></li>
<li>Haskell STM <a href="http://www.haskell.org/haskellwiki/Software_transactional_memory">chapter</a> in <a href="http://www.amazon.com/Beautiful-Code-Leading-Programmers-Practice/dp/0596510047">Beautiful code</a> </li>
<li><a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/">Persistent map </a> and <a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation/">vector</a> implementations.</li>
<li><a href="https://github.com/clojure/clojure">Clojure source code</a></li>
</ul>
</div>
</div></div>

</body>
</html>
